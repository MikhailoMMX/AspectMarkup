// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, John Gough, QUT 2005-2014
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.5.2
// Machine:  BLUEGENE
// DateTime: 25.08.2015 17:34:26
// UserName: MikhailoMMX
// Input file <ParserGen.y - 18.08.2015 18:05:54>

// options: no-lines gplex

using System;
using System.Collections.Generic;
using System.CodeDom.Compiler;
using System.Globalization;
using System.Text;
using QUT.Gppg;

namespace ParserGenerator
{
public enum Tokens {error=2,EOF=3,Token=4,RegExp=5,tkList=6,
    tkRule=7,tkSkip=8,tkBlock=9,tkRegExToken=10,tkNested=11,tkBegin=12,
    tkEnd=13,tkBeginEnd=14,tkEscapeSymbol=15,tkOpen=16,tkClose=17,tkAny=18,
    tkAnyExcept=19,tkColon=20,tkPipe=21,tkAt=22,tkSharp=23,tkQuest=24,
    tkPlus=25,tkStar=26,tkPercent=27,tkEq=28,tkSquareOpen=29,tkSquareClose=30,
    tkRoundOpen=31,tkRoundClose=32,tkComma=33,tkCaseSensitive=34,tkCaseInsensitive=35,tkExtension=36,
    tkRegion=37,tkPreprocessor=38,tkNamespace=39,tkDefine=40,tkUndef=41,tkIfdef=42,
    tkIfndef=43,tkElse=44,tkElif=45};

public partial class ValueType
{ 
  public string sVal;  
  public List<string> sList;
  public HashSet<string> sHS;
  public SourceFile sf;
  public Declaration Decl;
  public SkipDeclaration skipDs;
  public RuleDeclaration ruleDs;
  public SubRuleRepetition srRep;
  public SubRulePart srp;
  public List<SubRulePart> srpL;
  public bool flag;
}
// Abstract base class for GPLEX scanners
[GeneratedCodeAttribute( "Gardens Point Parser Generator", "1.5.2")]
public abstract class ScanBase : AbstractScanner<ValueType,LexLocation> {
  private LexLocation __yylloc = new LexLocation();
  public override LexLocation yylloc { get { return __yylloc; } set { __yylloc = value; } }
  protected virtual bool yywrap() { return true; }
}

// Utility class for encapsulating token information
[GeneratedCodeAttribute( "Gardens Point Parser Generator", "1.5.2")]
public class ScanObj {
  public int token;
  public ValueType yylval;
  public LexLocation yylloc;
  public ScanObj( int t, ValueType val, LexLocation loc ) {
    this.token = t; this.yylval = val; this.yylloc = loc;
  }
}

[GeneratedCodeAttribute( "Gardens Point Parser Generator", "1.5.2")]
public partial class Parser: ShiftReduceParser<ValueType, LexLocation>
{
#pragma warning disable 649
  private static Dictionary<int, string> aliases;
#pragma warning restore 649
  private static Rule[] rules = new Rule[60];
  private static State[] states = new State[105];
  private static string[] nonTerms = new string[] {
      "Program", "Declaration", "SkipParameters", "SkipParam", "TokenList", "TokenCommaList", 
      "SubRules", "UseNameValue", "Repetition", "SubRuleToken", "SubRule", "UseRuleName", 
      "ExceptList", "$accept", "Directive", "Anon@1", "PreProcDirective", "PreProcDirectivePart", 
      };

  static Parser() {
    states[0] = new State(-2,new int[]{-1,1}, new int[]{1,0});
    states[1] = new State(new int[]{3,2,2,4,8,5,7,19,27,61,10,101},new int[]{-2,3}, new int[]{1,1});
    states[2] = new State(-1,new int[]{}, new int[]{1,2});
    states[3] = new State(-3,new int[]{}, new int[]{3,2});
    states[4] = new State(-4,new int[]{}, new int[]{4,1});
    states[5] = new State(-10,new int[]{-3,6}, new int[]{5,1});
    states[6] = new State(new int[]{11,8,12,9,13,12,14,14,15,16,38,18,3,-5,2,-5,8,-5,7,-5,27,-5,10,-5},new int[]{-4,7}, new int[]{5,2});
    states[7] = new State(-11,new int[]{}, new int[]{11,2});
    states[8] = new State(-12,new int[]{}, new int[]{12,1});
    states[9] = new State(-18,new int[]{-5,10}, new int[]{13,1});
    states[10] = new State(new int[]{4,11,11,-13,12,-13,13,-13,14,-13,15,-13,38,-13,3,-13,2,-13,8,-13,7,-13,27,-13,10,-13},new int[]{}, new int[]{13,2});
    states[11] = new State(-19,new int[]{}, new int[]{19,2});
    states[12] = new State(-18,new int[]{-5,13}, new int[]{14,1});
    states[13] = new State(new int[]{4,11,11,-14,12,-14,13,-14,14,-14,15,-14,38,-14,3,-14,2,-14,8,-14,7,-14,27,-14,10,-14},new int[]{}, new int[]{14,2});
    states[14] = new State(-18,new int[]{-5,15}, new int[]{15,1});
    states[15] = new State(new int[]{4,11,11,-15,12,-15,13,-15,14,-15,15,-15,38,-15,3,-15,2,-15,8,-15,7,-15,27,-15,10,-15},new int[]{}, new int[]{15,2});
    states[16] = new State(-18,new int[]{-5,17}, new int[]{16,1});
    states[17] = new State(new int[]{4,11,11,-16,12,-16,13,-16,14,-16,15,-16,38,-16,3,-16,2,-16,8,-16,7,-16,27,-16,10,-16},new int[]{}, new int[]{16,2});
    states[18] = new State(-17,new int[]{}, new int[]{17,1});
    states[19] = new State(new int[]{22,60,4,-28},new int[]{-12,20}, new int[]{6,1});
    states[20] = new State(new int[]{4,21},new int[]{}, new int[]{6,2});
    states[21] = new State(new int[]{20,22},new int[]{}, new int[]{6,3});
    states[22] = new State(-39,new int[]{-7,23,-11,59}, new int[]{6,4});
    states[23] = new State(new int[]{21,24,3,-6,2,-6,8,-6,7,-6,27,-6,10,-6},new int[]{}, new int[]{6,5});
    states[24] = new State(-39,new int[]{-11,25}, new int[]{42,2});
    states[25] = new State(new int[]{22,51,23,53,29,55,21,-42,3,-42,2,-42,8,-42,7,-42,27,-42,10,-42,30,-42,4,-23,18,-23,19,-23,6,-23},new int[]{-10,26,-8,27}, new int[]{42,3});
    states[26] = new State(-40,new int[]{}, new int[]{40,2});
    states[27] = new State(new int[]{4,28,18,33,19,35,6,43},new int[]{}, new int[]{34,1,35,1,36,1,37,1});
    states[28] = new State(new int[]{24,30,25,31,26,32,22,-30,23,-30,29,-30,4,-30,18,-30,19,-30,6,-30,21,-30,3,-30,2,-30,8,-30,7,-30,27,-30,10,-30,30,-30},new int[]{-9,29}, new int[]{34,2});
    states[29] = new State(-34,new int[]{}, new int[]{34,3});
    states[30] = new State(-31,new int[]{}, new int[]{31,1});
    states[31] = new State(-32,new int[]{}, new int[]{32,1});
    states[32] = new State(-33,new int[]{}, new int[]{33,1});
    states[33] = new State(new int[]{24,30,25,31,26,32,22,-30,23,-30,29,-30,4,-30,18,-30,19,-30,6,-30,21,-30,3,-30,2,-30,8,-30,7,-30,27,-30,10,-30,30,-30},new int[]{-9,34}, new int[]{35,2});
    states[34] = new State(-35,new int[]{}, new int[]{35,3});
    states[35] = new State(new int[]{31,36},new int[]{}, new int[]{36,2});
    states[36] = new State(new int[]{4,42},new int[]{-13,37}, new int[]{36,3});
    states[37] = new State(new int[]{32,38,33,40},new int[]{}, new int[]{36,4});
    states[38] = new State(new int[]{24,30,25,31,26,32,22,-30,23,-30,29,-30,4,-30,18,-30,19,-30,6,-30,21,-30,3,-30,2,-30,8,-30,7,-30,27,-30,10,-30,30,-30},new int[]{-9,39}, new int[]{36,5});
    states[39] = new State(-36,new int[]{}, new int[]{36,6});
    states[40] = new State(new int[]{4,41},new int[]{}, new int[]{44,2});
    states[41] = new State(-44,new int[]{}, new int[]{44,3});
    states[42] = new State(-43,new int[]{}, new int[]{43,1});
    states[43] = new State(new int[]{31,44},new int[]{}, new int[]{37,2});
    states[44] = new State(new int[]{4,50,32,-20,33,-20},new int[]{-6,45}, new int[]{37,3});
    states[45] = new State(new int[]{32,46,33,48},new int[]{}, new int[]{37,4});
    states[46] = new State(new int[]{24,30,25,31,26,32,22,-30,23,-30,29,-30,4,-30,18,-30,19,-30,6,-30,21,-30,3,-30,2,-30,8,-30,7,-30,27,-30,10,-30,30,-30},new int[]{-9,47}, new int[]{37,5});
    states[47] = new State(-37,new int[]{}, new int[]{37,6});
    states[48] = new State(new int[]{4,49},new int[]{}, new int[]{22,2});
    states[49] = new State(-22,new int[]{}, new int[]{22,3});
    states[50] = new State(-21,new int[]{}, new int[]{21,1});
    states[51] = new State(new int[]{23,52,4,-24,18,-24,19,-24,6,-24},new int[]{}, new int[]{24,1,26,1});
    states[52] = new State(-26,new int[]{}, new int[]{26,2});
    states[53] = new State(new int[]{22,54,4,-25,18,-25,19,-25,6,-25},new int[]{}, new int[]{25,1,27,1});
    states[54] = new State(-27,new int[]{}, new int[]{27,2});
    states[55] = new State(-39,new int[]{-7,56,-11,59}, new int[]{38,1});
    states[56] = new State(new int[]{30,57,21,24},new int[]{}, new int[]{38,2});
    states[57] = new State(new int[]{24,30,25,31,26,32,22,-30,23,-30,29,-30,4,-30,18,-30,19,-30,6,-30,21,-30,3,-30,2,-30,8,-30,7,-30,27,-30,10,-30,30,-30},new int[]{-9,58}, new int[]{38,3});
    states[58] = new State(-38,new int[]{}, new int[]{38,4});
    states[59] = new State(new int[]{22,51,23,53,29,55,21,-41,3,-41,2,-41,8,-41,7,-41,27,-41,10,-41,30,-41,4,-23,18,-23,19,-23,6,-23},new int[]{-10,26,-8,27}, new int[]{41,1});
    states[60] = new State(-29,new int[]{}, new int[]{29,1});
    states[61] = new State(new int[]{34,63,35,64,36,65,37,67,38,74,39,99},new int[]{-15,62}, new int[]{7,1});
    states[62] = new State(-7,new int[]{}, new int[]{7,2});
    states[63] = new State(-45,new int[]{}, new int[]{45,1});
    states[64] = new State(-46,new int[]{}, new int[]{46,1});
    states[65] = new State(-18,new int[]{-5,66}, new int[]{47,1});
    states[66] = new State(new int[]{4,11,3,-47,2,-47,8,-47,7,-47,27,-47,10,-47},new int[]{}, new int[]{47,2});
    states[67] = new State(new int[]{12,68},new int[]{}, new int[]{48,1});
    states[68] = new State(new int[]{28,69},new int[]{}, new int[]{48,2});
    states[69] = new State(new int[]{4,70},new int[]{}, new int[]{48,3});
    states[70] = new State(new int[]{13,71},new int[]{}, new int[]{48,4});
    states[71] = new State(new int[]{28,72},new int[]{}, new int[]{48,5});
    states[72] = new State(new int[]{4,73},new int[]{}, new int[]{48,6});
    states[73] = new State(-48,new int[]{}, new int[]{48,7});
    states[74] = new State(new int[]{40,77,41,80,42,83,43,86,44,89,45,92,13,95},new int[]{-17,75,-18,98}, new int[]{49,1});
    states[75] = new State(new int[]{40,77,41,80,42,83,43,86,44,89,45,92,13,95,3,-49,2,-49,8,-49,7,-49,27,-49,10,-49},new int[]{-18,76}, new int[]{49,2});
    states[76] = new State(-52,new int[]{}, new int[]{52,2});
    states[77] = new State(new int[]{28,78},new int[]{}, new int[]{53,1});
    states[78] = new State(new int[]{4,79},new int[]{}, new int[]{53,2});
    states[79] = new State(-53,new int[]{}, new int[]{53,3});
    states[80] = new State(new int[]{28,81},new int[]{}, new int[]{54,1});
    states[81] = new State(new int[]{4,82},new int[]{}, new int[]{54,2});
    states[82] = new State(-54,new int[]{}, new int[]{54,3});
    states[83] = new State(new int[]{28,84},new int[]{}, new int[]{55,1});
    states[84] = new State(new int[]{4,85},new int[]{}, new int[]{55,2});
    states[85] = new State(-55,new int[]{}, new int[]{55,3});
    states[86] = new State(new int[]{28,87},new int[]{}, new int[]{56,1});
    states[87] = new State(new int[]{4,88},new int[]{}, new int[]{56,2});
    states[88] = new State(-56,new int[]{}, new int[]{56,3});
    states[89] = new State(new int[]{28,90},new int[]{}, new int[]{57,1});
    states[90] = new State(new int[]{4,91},new int[]{}, new int[]{57,2});
    states[91] = new State(-57,new int[]{}, new int[]{57,3});
    states[92] = new State(new int[]{28,93},new int[]{}, new int[]{58,1});
    states[93] = new State(new int[]{4,94},new int[]{}, new int[]{58,2});
    states[94] = new State(-58,new int[]{}, new int[]{58,3});
    states[95] = new State(new int[]{28,96},new int[]{}, new int[]{59,1});
    states[96] = new State(new int[]{4,97},new int[]{}, new int[]{59,2});
    states[97] = new State(-59,new int[]{}, new int[]{59,3});
    states[98] = new State(-51,new int[]{}, new int[]{51,1});
    states[99] = new State(new int[]{4,100},new int[]{}, new int[]{50,1});
    states[100] = new State(-50,new int[]{}, new int[]{50,2});
    states[101] = new State(new int[]{4,102},new int[]{}, new int[]{9,1});
    states[102] = new State(-8,new int[]{-16,103}, new int[]{9,2});
    states[103] = new State(new int[]{5,104},new int[]{}, new int[]{9,3});
    states[104] = new State(-9,new int[]{}, new int[]{9,4});

    for (int sNo = 0; sNo < states.Length; sNo++) states[sNo].number = sNo;

    rules[1] = new Rule(-14, new int[]{-1,3});
    rules[2] = new Rule(-1, new int[]{});
    rules[3] = new Rule(-1, new int[]{-1,-2});
    rules[4] = new Rule(-2, new int[]{2});
    rules[5] = new Rule(-2, new int[]{8,-3});
    rules[6] = new Rule(-2, new int[]{7,-12,4,20,-7});
    rules[7] = new Rule(-2, new int[]{27,-15});
    rules[8] = new Rule(-16, new int[]{});
    rules[9] = new Rule(-2, new int[]{10,4,-16,5});
    rules[10] = new Rule(-3, new int[]{});
    rules[11] = new Rule(-3, new int[]{-3,-4});
    rules[12] = new Rule(-4, new int[]{11});
    rules[13] = new Rule(-4, new int[]{12,-5});
    rules[14] = new Rule(-4, new int[]{13,-5});
    rules[15] = new Rule(-4, new int[]{14,-5});
    rules[16] = new Rule(-4, new int[]{15,-5});
    rules[17] = new Rule(-4, new int[]{38});
    rules[18] = new Rule(-5, new int[]{});
    rules[19] = new Rule(-5, new int[]{-5,4});
    rules[20] = new Rule(-6, new int[]{});
    rules[21] = new Rule(-6, new int[]{4});
    rules[22] = new Rule(-6, new int[]{-6,33,4});
    rules[23] = new Rule(-8, new int[]{});
    rules[24] = new Rule(-8, new int[]{22});
    rules[25] = new Rule(-8, new int[]{23});
    rules[26] = new Rule(-8, new int[]{22,23});
    rules[27] = new Rule(-8, new int[]{23,22});
    rules[28] = new Rule(-12, new int[]{});
    rules[29] = new Rule(-12, new int[]{22});
    rules[30] = new Rule(-9, new int[]{});
    rules[31] = new Rule(-9, new int[]{24});
    rules[32] = new Rule(-9, new int[]{25});
    rules[33] = new Rule(-9, new int[]{26});
    rules[34] = new Rule(-10, new int[]{-8,4,-9});
    rules[35] = new Rule(-10, new int[]{-8,18,-9});
    rules[36] = new Rule(-10, new int[]{-8,19,31,-13,32,-9});
    rules[37] = new Rule(-10, new int[]{-8,6,31,-6,32,-9});
    rules[38] = new Rule(-10, new int[]{29,-7,30,-9});
    rules[39] = new Rule(-11, new int[]{});
    rules[40] = new Rule(-11, new int[]{-11,-10});
    rules[41] = new Rule(-7, new int[]{-11});
    rules[42] = new Rule(-7, new int[]{-7,21,-11});
    rules[43] = new Rule(-13, new int[]{4});
    rules[44] = new Rule(-13, new int[]{-13,33,4});
    rules[45] = new Rule(-15, new int[]{34});
    rules[46] = new Rule(-15, new int[]{35});
    rules[47] = new Rule(-15, new int[]{36,-5});
    rules[48] = new Rule(-15, new int[]{37,12,28,4,13,28,4});
    rules[49] = new Rule(-15, new int[]{38,-17});
    rules[50] = new Rule(-15, new int[]{39,4});
    rules[51] = new Rule(-17, new int[]{-18});
    rules[52] = new Rule(-17, new int[]{-17,-18});
    rules[53] = new Rule(-18, new int[]{40,28,4});
    rules[54] = new Rule(-18, new int[]{41,28,4});
    rules[55] = new Rule(-18, new int[]{42,28,4});
    rules[56] = new Rule(-18, new int[]{43,28,4});
    rules[57] = new Rule(-18, new int[]{44,28,4});
    rules[58] = new Rule(-18, new int[]{45,28,4});
    rules[59] = new Rule(-18, new int[]{13,28,4});
  }

  protected override void Initialize() {
    this.InitSpecialTokens((int)Tokens.error, (int)Tokens.EOF);
    this.InitStates(states);
    this.InitRules(rules);
    this.InitNonTerminals(nonTerms);
  }

  protected override void DoAction(int action)
  {
    CurrentSemanticValue = new ValueType();
#pragma warning disable 162, 1522
    switch (action)
    {
      case 2: // Program -> /* empty */
{
		CurrentSemanticValue.sf = new SourceFile();
		root = CurrentSemanticValue.sf;
	}
        break;
      case 3: // Program -> Program, Declaration
{
		CurrentSemanticValue.sf = ValueStack[ValueStack.Depth-2].sf;
		if (ValueStack[ValueStack.Depth-1].Decl != null)
		{
			ValueStack[ValueStack.Depth-1].Decl.Location = LocationStack[LocationStack.Depth-1];
			CurrentSemanticValue.sf.Declarations.Add(ValueStack[ValueStack.Depth-1].Decl);
		}
	}
        break;
      case 4: // Declaration -> error
{
	}
        break;
      case 5: // Declaration -> tkSkip, SkipParameters
{
		CurrentSemanticValue.Decl = new SkipDeclaration();
		(CurrentSemanticValue.Decl as SkipDeclaration).Merge(ValueStack[ValueStack.Depth-1].skipDs);
	}
        break;
      case 6: // Declaration -> tkRule, UseRuleName, Token, tkColon, SubRules
{
		RuleDeclaration rd = new RuleDeclaration();
		rd.UseRuleName = ValueStack[ValueStack.Depth-4].flag;
		rd.Name = ValueStack[ValueStack.Depth-3].sVal;
		rd.Merge(ValueStack[ValueStack.Depth-1].ruleDs);
		CurrentSemanticValue.Decl = rd;
	}
        break;
      case 8: // Anon@1 -> /* empty */
{(Scanner as Scanner).BeginRegexp();}
        break;
      case 9: // Declaration -> tkRegExToken, Token, Anon@1, RegExp
{
		CurrentSemanticValue.Decl = new RegExTokenDeclaration(ValueStack[ValueStack.Depth-3].sVal, ValueStack[ValueStack.Depth-1].sVal);
	}
        break;
      case 10: // SkipParameters -> /* empty */
{
		CurrentSemanticValue.skipDs = new SkipDeclaration();
	}
        break;
      case 11: // SkipParameters -> SkipParameters, SkipParam
{
		CurrentSemanticValue.skipDs = ValueStack[ValueStack.Depth-2].skipDs;
		CurrentSemanticValue.skipDs.Merge(ValueStack[ValueStack.Depth-1].skipDs);
	}
        break;
      case 12: // SkipParam -> tkNested
{
		CurrentSemanticValue.skipDs = new SkipDeclaration();
		CurrentSemanticValue.skipDs.Nested = true;
	}
        break;
      case 13: // SkipParam -> tkBegin, TokenList
{
		CurrentSemanticValue.skipDs = new SkipDeclaration();
		CurrentSemanticValue.skipDs.Begin.AddRange(ValueStack[ValueStack.Depth-1].sList.ToArray());
	}
        break;
      case 14: // SkipParam -> tkEnd, TokenList
{
		CurrentSemanticValue.skipDs = new SkipDeclaration();
		CurrentSemanticValue.skipDs.End.AddRange(ValueStack[ValueStack.Depth-1].sList.ToArray());
	}
        break;
      case 15: // SkipParam -> tkBeginEnd, TokenList
{
		CurrentSemanticValue.skipDs = new SkipDeclaration();
		CurrentSemanticValue.skipDs.Begin.AddRange(ValueStack[ValueStack.Depth-1].sList.ToArray());
		CurrentSemanticValue.skipDs.End.AddRange(ValueStack[ValueStack.Depth-1].sList.ToArray());
	}
        break;
      case 16: // SkipParam -> tkEscapeSymbol, TokenList
{
		CurrentSemanticValue.skipDs = new SkipDeclaration();
		CurrentSemanticValue.skipDs.EscapeSymbol.AddRange(ValueStack[ValueStack.Depth-1].sList.ToArray());
	}
        break;
      case 17: // SkipParam -> tkPreprocessor
{
		CurrentSemanticValue.skipDs = new SkipDeclaration();
		CurrentSemanticValue.skipDs.Preprocessor = true;
	}
        break;
      case 18: // TokenList -> /* empty */
{
		CurrentSemanticValue.sList = new List<string>();
	}
        break;
      case 19: // TokenList -> TokenList, Token
{
		CurrentSemanticValue.sList = ValueStack[ValueStack.Depth-2].sList;
		CurrentSemanticValue.sList.Add(ValueStack[ValueStack.Depth-1].sVal);
	}
        break;
      case 20: // TokenCommaList -> /* empty */
{
		CurrentSemanticValue.sList = new List<string>();
	}
        break;
      case 21: // TokenCommaList -> Token
{
		CurrentSemanticValue.sList = new List<string>();
		CurrentSemanticValue.sList.Add(ValueStack[ValueStack.Depth-1].sVal);
	}
        break;
      case 22: // TokenCommaList -> TokenCommaList, tkComma, Token
{
		CurrentSemanticValue.sList = ValueStack[ValueStack.Depth-3].sList;
		CurrentSemanticValue.sList.Add(ValueStack[ValueStack.Depth-1].sVal);
	}
        break;
      case 23: // UseNameValue -> /* empty */
{CurrentSemanticValue.sVal = "";}
        break;
      case 24: // UseNameValue -> tkAt
{CurrentSemanticValue.sVal = "@";}
        break;
      case 25: // UseNameValue -> tkSharp
{CurrentSemanticValue.sVal = "#";}
        break;
      case 26: // UseNameValue -> tkAt, tkSharp
{CurrentSemanticValue.sVal = "@#";}
        break;
      case 27: // UseNameValue -> tkSharp, tkAt
{CurrentSemanticValue.sVal = "@#";}
        break;
      case 28: // UseRuleName -> /* empty */
{CurrentSemanticValue.flag = false; }
        break;
      case 29: // UseRuleName -> tkAt
{CurrentSemanticValue.flag = true; }
        break;
      case 30: // Repetition -> /* empty */
{CurrentSemanticValue.srRep = SubRuleRepetition.Once;}
        break;
      case 31: // Repetition -> tkQuest
{CurrentSemanticValue.srRep = SubRuleRepetition.ZeroOrOne;}
        break;
      case 32: // Repetition -> tkPlus
{CurrentSemanticValue.srRep = SubRuleRepetition.OneOrMore;}
        break;
      case 33: // Repetition -> tkStar
{CurrentSemanticValue.srRep = SubRuleRepetition.ZeroOrMore;}
        break;
      case 34: // SubRuleToken -> UseNameValue, Token, Repetition
{
		SubRulePart srp = new SubRulePart(ValueStack[ValueStack.Depth-2].sVal);
		srp.UseName = ValueStack[ValueStack.Depth-3].sVal == "@" || ValueStack[ValueStack.Depth-3].sVal == "@#";
		srp.UseValue = ValueStack[ValueStack.Depth-3].sVal == "#" || ValueStack[ValueStack.Depth-3].sVal == "@#";
		srp.Repetition = ValueStack[ValueStack.Depth-1].srRep;
		CurrentSemanticValue.srp = srp;
	}
        break;
      case 35: // SubRuleToken -> UseNameValue, tkAny, Repetition
{
		SubRuleAny sr = new SubRuleAny();
		sr.UseName = ValueStack[ValueStack.Depth-3].sVal == "@" || ValueStack[ValueStack.Depth-3].sVal == "@#";
		sr.UseValue = ValueStack[ValueStack.Depth-3].sVal == "#" || ValueStack[ValueStack.Depth-3].sVal == "@#";
		sr.Repetition = ValueStack[ValueStack.Depth-1].srRep;
		CurrentSemanticValue.srp = sr;
	}
        break;
      case 36: // SubRuleToken -> UseNameValue, tkAnyExcept, tkRoundOpen, ExceptList, 
               //                 tkRoundClose, Repetition
{
		SubRuleAny sr = new SubRuleAny();
		sr.UseName = ValueStack[ValueStack.Depth-6].sVal == "@" || ValueStack[ValueStack.Depth-6].sVal == "@#";
		sr.UseValue = ValueStack[ValueStack.Depth-6].sVal == "#" || ValueStack[ValueStack.Depth-6].sVal == "@#";
		sr.Repetition = ValueStack[ValueStack.Depth-1].srRep;
		sr.Except = ValueStack[ValueStack.Depth-3].sHS;
		CurrentSemanticValue.srp = sr;
	}
        break;
      case 37: // SubRuleToken -> UseNameValue, tkList, tkRoundOpen, TokenCommaList, tkRoundClose, 
               //                 Repetition
{
		if (ValueStack[ValueStack.Depth-3].sList.Count == 0 || ValueStack[ValueStack.Depth-3].sList.Count>2)
			ErrorReporter.WriteError(ErrorMessages.WrongListParameters, LocationStack[LocationStack.Depth-5]);
		else
		{
			string NT = ValueStack[ValueStack.Depth-3].sList[0];
			string Sep = "";
			if (ValueStack[ValueStack.Depth-3].sList.Count > 1)
				Sep = ValueStack[ValueStack.Depth-3].sList[1];
			SubRuleNonTermList sr = new SubRuleNonTermList(NT, Sep);
			sr.UseName = ValueStack[ValueStack.Depth-6].sVal == "@" || ValueStack[ValueStack.Depth-6].sVal == "@#";
			sr.CanBeEmpty = ValueStack[ValueStack.Depth-5].sVal == StringConstants.tkList0;
			sr.Repetition = ValueStack[ValueStack.Depth-1].srRep;
			CurrentSemanticValue.srp = sr;
		}
	}
        break;
      case 38: // SubRuleToken -> tkSquareOpen, SubRules, tkSquareClose, Repetition
{
		CurrentSemanticValue.srp = new SubRuleComplexPart(ValueStack[ValueStack.Depth-3].ruleDs.SubRules);
		CurrentSemanticValue.srp.Repetition = ValueStack[ValueStack.Depth-1].srRep;
	}
        break;
      case 39: // SubRule -> /* empty */
{CurrentSemanticValue.srpL = new List<SubRulePart>();}
        break;
      case 40: // SubRule -> SubRule, SubRuleToken
{
		CurrentSemanticValue.srpL = ValueStack[ValueStack.Depth-2].srpL;
		CurrentSemanticValue.srpL.Add(ValueStack[ValueStack.Depth-1].srp);
		ValueStack[ValueStack.Depth-1].srp.Location = LocationStack[LocationStack.Depth-1];
	}
        break;
      case 41: // SubRules -> SubRule
{
		CurrentSemanticValue.ruleDs = new RuleDeclaration();
		CurrentSemanticValue.ruleDs.SubRules.Add(ValueStack[ValueStack.Depth-1].srpL);
	}
        break;
      case 42: // SubRules -> SubRules, tkPipe, SubRule
{
		CurrentSemanticValue.ruleDs = ValueStack[ValueStack.Depth-3].ruleDs;
		CurrentSemanticValue.ruleDs.SubRules.Add(ValueStack[ValueStack.Depth-1].srpL);
		CurrentSemanticValue.ruleDs.Location = LocationStack[LocationStack.Depth-3].Merge(LocationStack[LocationStack.Depth-1]);
	}
        break;
      case 43: // ExceptList -> Token
{CurrentSemanticValue.sHS = new HashSet<string>(); CurrentSemanticValue.sHS.Add(ValueStack[ValueStack.Depth-1].sVal); }
        break;
      case 44: // ExceptList -> ExceptList, tkComma, Token
{CurrentSemanticValue.sHS = ValueStack[ValueStack.Depth-3].sHS; CurrentSemanticValue.sHS.Add(ValueStack[ValueStack.Depth-1].sVal); }
        break;
      case 45: // Directive -> tkCaseSensitive
{Options.CaseInsensitive = false;}
        break;
      case 46: // Directive -> tkCaseInsensitive
{Options.CaseInsensitive = true;}
        break;
      case 47: // Directive -> tkExtension, TokenList
{Options.ExtensionList = ValueStack[ValueStack.Depth-1].sList;}
        break;
      case 48: // Directive -> tkRegion, tkBegin, tkEq, Token, tkEnd, tkEq, Token
{
		Options.RegionBegin = ValueStack[ValueStack.Depth-4].sVal;
		Options.RegionEnd = ValueStack[ValueStack.Depth-1].sVal;
	}
        break;
      case 49: // Directive -> tkPreprocessor, PreProcDirective
{}
        break;
      case 50: // Directive -> tkNamespace, Token
{ Options.Namespace = ValueStack[ValueStack.Depth-1].sVal; }
        break;
      case 51: // PreProcDirective -> PreProcDirectivePart
{}
        break;
      case 52: // PreProcDirective -> PreProcDirective, PreProcDirectivePart
{}
        break;
      case 53: // PreProcDirectivePart -> tkDefine, tkEq, Token
{Options.DirectiveDefine = ValueStack[ValueStack.Depth-1].sVal;}
        break;
      case 54: // PreProcDirectivePart -> tkUndef, tkEq, Token
{Options.DirectiveUndef = ValueStack[ValueStack.Depth-1].sVal;}
        break;
      case 55: // PreProcDirectivePart -> tkIfdef, tkEq, Token
{Options.DirectiveIfdef = ValueStack[ValueStack.Depth-1].sVal;}
        break;
      case 56: // PreProcDirectivePart -> tkIfndef, tkEq, Token
{Options.DirectiveIfndef = ValueStack[ValueStack.Depth-1].sVal;}
        break;
      case 57: // PreProcDirectivePart -> tkElse, tkEq, Token
{Options.DirectiveElse = ValueStack[ValueStack.Depth-1].sVal;}
        break;
      case 58: // PreProcDirectivePart -> tkElif, tkEq, Token
{Options.DirectiveElif = ValueStack[ValueStack.Depth-1].sVal;}
        break;
      case 59: // PreProcDirectivePart -> tkEnd, tkEq, Token
{Options.DirectiveEnd = ValueStack[ValueStack.Depth-1].sVal;}
        break;
    }
#pragma warning restore 162, 1522
  }

  protected override string TerminalToString(int terminal)
  {
    if (aliases != null && aliases.ContainsKey(terminal))
        return aliases[terminal];
    else if (((Tokens)terminal).ToString() != terminal.ToString(CultureInfo.InvariantCulture))
        return ((Tokens)terminal).ToString();
    else
        return CharToString((char)terminal);
  }

}
}
