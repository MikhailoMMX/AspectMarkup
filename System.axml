<?xml version="1.0" encoding="utf-16"?>
<AspectFile Version="3">
  <Node NL="0" NG="0">
    <Items>
      <Node Name="LP Генератор" NL="0" NG="0">
        <Items>
          <Node Name="Предварительные действия" NL="0" NG="0">
            <Items>
              <Node Name="AddPredefinedEntities" NL="0" NG="0">
                <FileName>\system\parsergenerator\engine.cs</FileName>
                <Text>private void AddPredefinedEntities()</Text>
                <OCtx>
                  <i Type="Method">private void AddPredefinedEntities ( )</i>
                  <i Type="ClassOrNamespace">public class Engine</i>
                  <i Type="ClassOrNamespace">namespace ParserGenerator</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
              <Node Name="AddSourceEntitiesToSymbolTable" NL="0" NG="0">
                <FileName>\system\parsergenerator\engine.cs</FileName>
                <Text>private void AddSourceEntitiesToSymbolTable(SourceFile source)</Text>
                <OCtx>
                  <i Type="Method">private void AddSourceEntitiesToSymbolTable ( SourceFile source )</i>
                  <i Type="ClassOrNamespace">public class Engine</i>
                  <i Type="ClassOrNamespace">namespace ParserGenerator</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
            </Items>
          </Node>
          <Node Name="Проверки" NL="0" NG="0">
            <Items>
              <Node Name="CheckExistenceOfUsedNames" NL="0" NG="0">
                <FileName>\system\parsergenerator\engine.cs</FileName>
                <Text>private void CheckExistenceOfUsedNames()</Text>
                <OCtx>
                  <i Type="Method">private void CheckExistenceOfUsedNames ( )</i>
                  <i Type="ClassOrNamespace">public class Engine</i>
                  <i Type="ClassOrNamespace">namespace ParserGenerator</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
              <Node Name="CheckList" NL="0" NG="0">
                <FileName>\system\parsergenerator\engine.cs</FileName>
                <Text>private void CheckList(List&lt;SubRulePart&gt; list, LexLocation location)</Text>
                <OCtx>
                  <i Type="Method">private void CheckList ( List &lt; SubRulePart &gt; list , LexLocation location )</i>
                  <i Type="ClassOrNamespace">public class Engine</i>
                  <i Type="ClassOrNamespace">namespace ParserGenerator</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
              <Node Name="CheckList" NL="0" NG="0">
                <FileName>\system\parsergenerator\engine.cs</FileName>
                <Text>private void CheckList(List&lt;string&gt; list, LexLocation location)</Text>
                <OCtx>
                  <i Type="Method">private void CheckList ( List &lt; string &gt; list , LexLocation location )</i>
                  <i Type="ClassOrNamespace">public class Engine</i>
                  <i Type="ClassOrNamespace">namespace ParserGenerator</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
              <Node Name="CheckOrAddPredefinedName" NL="0" NG="0">
                <FileName>\system\parsergenerator\engine.cs</FileName>
                <Text>private void CheckOrAddPredefinedName(string name, LexLocation location)</Text>
                <OCtx>
                  <i Type="Method">private void CheckOrAddPredefinedName ( string name , LexLocation location )</i>
                  <i Type="ClassOrNamespace">public class Engine</i>
                  <i Type="ClassOrNamespace">namespace ParserGenerator</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
            </Items>
          </Node>
          <Node Name="Упрощения" NL="0" NG="0">
            <Items>
              <Node Name="SimplifyTokenOnlyRules" NL="0" NG="0">
                <FileName>\system\parsergenerator\engine.cs</FileName>
                <Text>private void SimplifyTokenOnlyRules()</Text>
                <OCtx>
                  <i Type="Method">private void SimplifyTokenOnlyRules ( )</i>
                  <i Type="ClassOrNamespace">public class Engine</i>
                  <i Type="ClassOrNamespace">namespace ParserGenerator</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
              <Node Name="MarkRulesWithoutNode" NL="0" NG="0">
                <FileName>\system\parsergenerator\engine.cs</FileName>
                <Text>private void MarkRulesWithoutNode()</Text>
                <OCtx>
                  <i Type="Method">private void MarkRulesWithoutNode ( )</i>
                  <i Type="ClassOrNamespace">public class Engine</i>
                  <i Type="ClassOrNamespace">namespace ParserGenerator</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
              <Node Name="MarkUnnamedRules" NL="0" NG="0">
                <FileName>\system\parsergenerator\engine.cs</FileName>
                <Text>private void MarkUnnamedRules()</Text>
                <OCtx>
                  <i Type="Method">private void MarkUnnamedRules ( )</i>
                  <i Type="ClassOrNamespace">public class Engine</i>
                  <i Type="ClassOrNamespace">namespace ParserGenerator</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
            </Items>
          </Node>
          <Node Name="Однородные наборы" NL="0" NG="0">
            <Items>
              <Node Name="Класс SubRuleNonTermList" NL="0" NG="0">
                <FileName>\system\parsergenerator\classes.cs</FileName>
                <Note>Унаследованное от базового класса поле Name хранит имя нетерминала, описывающего подузлы.
Дополнительно вводятся поля для хранения разделителя и возможности удаления последнего подузла.</Note>
                <Text>public class SubRuleNonTermList : SubRulePart</Text>
                <OCtx>
                  <i Type="">public class SubRuleNonTermList : SubRulePart</i>
                  <i Type="">namespace ParserGenerator</i>
                  <i Type="">
                  </i>
                </OCtx>
                <Items>
                  <Node Name="Separator" NL="0" NG="0">
                    <FileName>\System\parsergenerator\Classes.cs</FileName>
                    <Note>Хранит строковое представление разделителя между элементами однородного набора.
Если строка пустая - разделитель не используется.</Note>
                    <Text>public string Separator;</Text>
                    <OCtx>
                      <i Type="">public string Separator</i>
                      <i Type="">public class SubRuleNonTermList : SubRulePart</i>
                      <i Type="">namespace ParserGenerator</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="CanBeEmpty" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\Classes.cs</FileName>
                    <Note>True означает, что узел может содержать 0 подузлов, а значит удалять последний подузел можно.
False - узел должен содержать хотя бы один подузел.</Note>
                    <Text>public bool CanBeEmpty;</Text>
                    <OCtx>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                </Items>
              </Node>
              <Node Name="Грамматика" NL="0" NG="0">
                <Items>
                  <Node Name="Ветка грамматики" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\ParserGen.y</FileName>
                    <Text>| 	UseNameValue tkList tkRoundOpen ExceptList tkRoundClose Repetition</Text>
                    <OCtx>
                      <i Type="">UseNameValue tkList tkRoundOpen TokenCommaList tkRoundClose Repetition Action</i>
                      <i Type="">SubRuleToken</i>
                      <i Type="">Section2</i>
                      <i Type="">Program</i>
                    </OCtx>
                  </Node>
                  <Node Name="Лексема tkList" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\ParserGen.y</FileName>
                    <Note>1 секция, объявление лексемы tkList.
После изменения парсера может потеряться</Note>
                    <Text>%token &lt;sVal&gt; Token RegExp tkList</Text>
                    <OCtx>
                      <i Type="">% token &lt; sVal &gt; Token RegExp tkList</i>
                      <i Type="">Section1</i>
                      <i Type="">Program</i>
                    </OCtx>
                  </Node>
                  <Node Name="TokenCommaList" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\ParserGen.y</FileName>
                    <Text>TokenCommaList</Text>
                    <OCtx>
                      <i Type="">TokenCommaList</i>
                      <i Type="">Section2</i>
                      <i Type="">Program</i>
                    </OCtx>
                  </Node>
                </Items>
              </Node>
              <Node Name="Класс UniformSetInfo" NL="0" NG="0">
                <FileName>\system\core\classes.cs</FileName>
                <Note>Содержит описание подузлов в данном узле, которые относятся к однородному набору</Note>
                <Text>public class UniformSetInfo</Text>
                <OCtx>
                  <i Type="">public class UniformSetInfo</i>
                  <i Type="">namespace AspectCore</i>
                  <i Type="">
                  </i>
                </OCtx>
              </Node>
              <Node Name="Класс SourceEntityUniformSet" NL="0" NG="0">
                <FileName>\system\core\classes.cs</FileName>
                <Note>Используется для хранения списка узлов, построенных по конструкции List. После добавления к родительскому узлу информация о нем переносится в поле UniformSet родительского узла, список узлов добавляется к родительскому узлу.</Note>
                <Text>public class SourceEntityUniformSet:SourceEntity</Text>
                <OCtx>
                  <i Type="">public class SourceEntityUniformSet : SourceEntity</i>
                  <i Type="">namespace AspectCore</i>
                  <i Type="">
                  </i>
                </OCtx>
              </Node>
              <Node Name="Константы" NL="0" NG="0">
                <Items>
                  <Node Name="Имя лексемы tkList0" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\StringConstants.cs</FileName>
                    <Text>public static string tkList0 = "List0";</Text>
                    <OCtx>
                      <i Type="">public static string tkList0 =</i>
                      <i Type="">class StringConstants</i>
                      <i Type="">namespace ParserGenerator</i>
                      <i Type="">
                      </i>
                    </OCtx>
                    <Items>
                      <Node Name="Добавление к ключевым словам" NL="0" NG="0">
                        <FileName>\System\ParserGenerator\ParserGenPart.cs</FileName>
                        <Text>keywords.Add(StringConstants.tkList0, (int)Tokens.tkList);</Text>
                        <OCtx>
                          <i Type="">static Keywords ( )</i>
                          <i Type="">public static class Keywords</i>
                          <i Type="">public sealed partial class Scanner : ScanBase</i>
                          <i Type="">namespace ParserGenerator</i>
                          <i Type="">
                          </i>
                        </OCtx>
                      </Node>
                    </Items>
                  </Node>
                  <Node Name="Имя лексемы tkList1" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\StringConstants.cs</FileName>
                    <Text>public static string tkList1 = "List1";</Text>
                    <OCtx>
                      <i Type="">public static string tkList1 =</i>
                      <i Type="">class StringConstants</i>
                      <i Type="">namespace ParserGenerator</i>
                      <i Type="">
                      </i>
                    </OCtx>
                    <Items>
                      <Node Name="Добавление к ключевым словам" NL="0" NG="0">
                        <FileName>\System\ParserGenerator\ParserGenPart.cs</FileName>
                        <Text>keywords.Add(StringConstants.tkList1, (int)Tokens.tkList);</Text>
                        <OCtx>
                          <i Type="">static Keywords ( )</i>
                          <i Type="">public static class Keywords</i>
                          <i Type="">public sealed partial class Scanner : ScanBase</i>
                          <i Type="">namespace ParserGenerator</i>
                          <i Type="">
                          </i>
                        </OCtx>
                      </Node>
                    </Items>
                  </Node>
                  <Node Name="Имя класса SourceEntityUniformSetClassName" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\StringConstants.cs</FileName>
                    <Note>Имя класса, использующегося для хранения узлов, построенных по конструкции List</Note>
                    <Text>public static string SourceEntityUniformSetClassName = "SourceEntityUniformSet";</Text>
                    <OCtx>
                      <i Type="">public static string SourceEntityUniformSetClassName =</i>
                      <i Type="">class StringConstants</i>
                      <i Type="">namespace ParserGenerator</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Ошибка - недопустимо несколько вхождений List" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\ErrorMessages.cs</FileName>
                    <Text>public static string MultipleListsNotAllowed = "Несколько вхождений List в одном правиле недопустимо";</Text>
                    <OCtx>
                      <i Type="">public static string MultipleListsNotAllowed =</i>
                      <i Type="">public class ErrorMessages</i>
                      <i Type="">namespace ParserGenerator</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Ошибка - недопустимо повторение списка" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\ErrorMessages.cs</FileName>
                    <Text>public static string RepetitionAfterListNotAllowed = "Символ повторения после List недопустим";</Text>
                    <OCtx>
                      <i Type="">public static string RepetitionAfterListNotAllowed =</i>
                      <i Type="">public class ErrorMessages</i>
                      <i Type="">namespace ParserGenerator</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Суффикс имени для нового правила" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\StringConstants.cs</FileName>
                    <Text>public static string tkUniformSetSuffix = "_set";</Text>
                    <OCtx>
                      <i Type="">public static string tkUniformSetSuffix =</i>
                      <i Type="">class StringConstants</i>
                      <i Type="">namespace ParserGenerator</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Действие для первой ветки правила" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\StringConstants.cs</FileName>
                    <Text>public static string YActionForSet1 =</Text>
                    <OCtx>
                      <i Type="">public static string YActionForSet1 =</i>
                      <i Type="">class StringConstants</i>
                      <i Type="">namespace ParserGenerator</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Действие для второй ветки правила" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\StringConstants.cs</FileName>
                    <Text>public static string YActionForSet2 =</Text>
                    <OCtx>
                      <i Type="">public static string YActionForSet2 =</i>
                      <i Type="">class StringConstants</i>
                      <i Type="">namespace ParserGenerator</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Ошибка - неправильный первый параметр List" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\ErrorMessages.cs</FileName>
                    <Text>public static string WrongFirstParamInList = "В правиле {0} первым параметром в List должно быть имя правила";</Text>
                    <OCtx>
                      <i Type="">public static string WrongFirstParamInList =</i>
                      <i Type="">public class ErrorMessages</i>
                      <i Type="">namespace ParserGenerator</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Ошибка - неправильный второй параметр List" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\ErrorMessages.cs</FileName>
                    <Text>public static string WrongSecondParamInList = "В правиле {0} вторым параметром в List должна быть строка или имя лексемы";</Text>
                    <OCtx>
                      <i Type="">public static string WrongSecondParamInList =</i>
                      <i Type="">public class ErrorMessages</i>
                      <i Type="">namespace ParserGenerator</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                </Items>
              </Node>
              <Node Name="Метод обработки" NL="0" NG="0">
                <FileName>\System\ParserGenerator\Engine.cs</FileName>
                <Text>private void ReplaceUniformListsWithRules()</Text>
                <OCtx>
                  <i Type="">private void ReplaceUniformListsWithRules ( )</i>
                  <i Type="">public class Engine</i>
                  <i Type="">namespace ParserGenerator</i>
                  <i Type="">
                  </i>
                </OCtx>
                <Items>
                  <Node Name="Основная часть во вспомогательном методе" NL="0" NG="0">
                    <FileName>\system\parsergenerator\engine.cs</FileName>
                    <Text>private void ReplaceUniformListsWithRules(List&lt;SubRulePart&gt; branch, string Name, LexLocation Loc)</Text>
                    <OCtx>
                      <i Type="">private void ReplaceUniformListsWithRules ( List &lt; SubRulePart &gt; branch , string RuleName , LexLocation Location )</i>
                      <i Type="">public class Engine</i>
                      <i Type="">namespace ParserGenerator</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Вызов в самом главном методе" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\Engine.cs</FileName>
                    <Text>ReplaceUniformListsWithRules();</Text>
                    <OCtx>
                      <i Type="">public SymbolTable ParseSourceFile ( SourceFile source )</i>
                      <i Type="">public class Engine</i>
                      <i Type="">namespace ParserGenerator</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                </Items>
              </Node>
              <Node Name="Дополнительные изменения" NL="0" NG="0">
                <Items>
                  <Node Name="Генерация Union" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\Generator.cs</FileName>
                    <Text>sbUnion.AppendFormat(StringConstants.YUnionEntry, StringConstants.SourceEntityUniformSetClassName);</Text>
                    <OCtx>
                      <i Type="">private void GenerateYACCFile ( )</i>
                      <i Type="">class Generator</i>
                      <i Type="">namespace ParserGenerator</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Генерация типов" NL="0" NG="0">
                    <FileName>\System\ParserGenerator\Generator.cs</FileName>
                    <Text>sb.AppendFormat(StringConstants.YType, rd.Value.Type, rd.Key);</Text>
                    <OCtx>
                      <i Type="">private string GenerateYTokensAndTypes ( )</i>
                      <i Type="">class Generator</i>
                      <i Type="">namespace ParserGenerator</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                </Items>
              </Node>
            </Items>
          </Node>
          <Node Name="Лексемы" NL="0" NG="0">
            <Items>
              <Node Name="DeclareInlinedTokens" NL="0" NG="0">
                <FileName>\system\parsergenerator\engine.cs</FileName>
                <Text>private void DeclareInlinedTokens()</Text>
                <OCtx>
                  <i Type="Method">private void DeclareInlinedTokens ( )</i>
                  <i Type="ClassOrNamespace">public class Engine</i>
                  <i Type="ClassOrNamespace">namespace ParserGenerator</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
              <Node Name="InlineTokensInUnnamedSkips" NL="0" NG="0">
                <FileName>\system\parsergenerator\engine.cs</FileName>
                <Text>private void InlineTokensInUnnamedSkips()</Text>
                <OCtx>
                  <i Type="Method">private void InlineTokensInUnnamedSkips ( )</i>
                  <i Type="ClassOrNamespace">public class Engine</i>
                  <i Type="ClassOrNamespace">namespace ParserGenerator</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
            </Items>
          </Node>
          <Node Name="Нетерминал ANY" NL="0" NG="0">
            <Items>
              <Node Name="ConvertANYToRules" NL="0" NG="0">
                <FileName>\system\parsergenerator\engine.cs</FileName>
                <Text>private void ConvertANYToRules()</Text>
                <OCtx>
                  <i Type="Method">private void ConvertANYToRules ( )</i>
                  <i Type="ClassOrNamespace">public class Engine</i>
                  <i Type="ClassOrNamespace">namespace ParserGenerator</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
            </Items>
          </Node>
          <Node Name="Правила" NL="0" NG="0">
            <Items>
              <Node Name="ConvertComplexSubruleParts" NL="0" NG="0">
                <FileName>\system\parsergenerator\engine.cs</FileName>
                <Text>private void ConvertComplexSubruleParts()</Text>
                <OCtx>
                  <i Type="Method">private void ConvertComplexSubruleParts ( )</i>
                  <i Type="ClassOrNamespace">public class Engine</i>
                  <i Type="ClassOrNamespace">namespace ParserGenerator</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
              <Node Name="ExpandRules" NL="0" NG="0">
                <FileName>\system\parsergenerator\engine.cs</FileName>
                <Text>private void ExpandRules()</Text>
                <OCtx>
                  <i Type="Method">private void ExpandRules ( )</i>
                  <i Type="ClassOrNamespace">public class Engine</i>
                  <i Type="ClassOrNamespace">namespace ParserGenerator</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
            </Items>
          </Node>
          <Node Name="Действия в правилах" NL="0" NG="0">
            <Items>
              <Node Name="AddActionsToRules" NL="0" NG="0">
                <FileName>\system\parsergenerator\engine.cs</FileName>
                <Text>private void AddActionsToRules()</Text>
                <OCtx>
                  <i Type="Method">private void AddActionsToRules ( )</i>
                  <i Type="ClassOrNamespace">public class Engine</i>
                  <i Type="ClassOrNamespace">namespace ParserGenerator</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
              <Node Name="GeneratePredefinedRules" NL="0" NG="0">
                <FileName>\system\parsergenerator\engine.cs</FileName>
                <Text>private void GeneratePredefinedRules()</Text>
                <OCtx>
                  <i Type="Method">private void GeneratePredefinedRules ( )</i>
                  <i Type="ClassOrNamespace">public class Engine</i>
                  <i Type="ClassOrNamespace">namespace ParserGenerator</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
            </Items>
          </Node>
          <Node Name="Ошибка: EscapeSymbol не один" NL="0" NG="0">
            <FileName>\Parsers\LWParserCS2\ParserDescriptor.lp</FileName>
            <Note>Не только апостроф, но и обратный слэш, который может экранировать апостроф</Note>
            <OCtx>
              <i Type="dSkip">Skip BeginEnd "'" EscapeSymbol "'"</i>
              <i Type="LP_TreeNode">
              </i>
            </OCtx>
          </Node>
        </Items>
      </Node>
      <Node Name="Ядро" NL="0" NG="0">
        <Items>
          <Node Name="TODO" NL="0" NG="0">
            <Items>
              <Node Name="Сохранение при закрытии" NL="0" NG="0">
                <FileName>\system\core\ui\aspectwindowpane.cs</FileName>
                <Note>Если файл еще не был сохранен - он потеряется при текущем условии
Нужно реагировать на закрытие, приостанавливать процесс и показывать диалог.</Note>
                <Text>public void SaveAspectFile()</Text>
                <OCtx>
                  <i Type="">public void SaveAspectFile ( )</i>
                  <i Type="">public partial class AspectWindowPane : UserControl , IAspectWindow</i>
                  <i Type="">namespace AspectCore</i>
                  <i Type="">
                  </i>
                </OCtx>
              </Node>
              <Node Name="FIXME: ошибка при сохранении" NL="0" NG="0">
                <FileName>\system\core\aspectmanager.cs</FileName>
                <Note>Если дерево аспектов ни разу не сохранялось, не было открыто из файла, но к нему были добавлены узлы (например, импортом) - при сохранении может быть ошибка вида "невозможно получить доступ к файлу "C:\.axm"".</Note>
                <Text>public void SerializeAspect(PointOfInterest subAspect, string FileName, bool Force = false)</Text>
                <OCtx>
                  <i Type="Method">public void SerializeAspect ( PointOfInterest subAspect , string FileName , bool Force = false )</i>
                  <i Type="ClassOrNamespace">public class AspectManager</i>
                  <i Type="ClassOrNamespace">namespace AspectCore</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
              <Node Name="FIXME: пути к файлам при импорте/экспорте" NL="0" NG="0">
                <FileName>\system\core\ui\aspectwindowpane.cs</FileName>
                <Note>При экспорте сохраняются относительные пути.
Если после этого импортировать файл в другом месте или в пустом файле (когда не инициализирована переменная текущего пути к аспектному файлу), то возникают ошибки.</Note>
                <OCtx>
                  <i Type="Method">private void ExportToolStripMenuItem_Click ( object sender , EventArgs e )</i>
                  <i Type="ClassOrNamespace">public partial class AspectWindowPane : UserControl , IAspectWindow</i>
                  <i Type="ClassOrNamespace">namespace AspectCore</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
              <Node Name="Разрешить привязку к пустой строке" NL="0" NG="0">
                <FileName>\system\core\helpers\editpointhelper.cs</FileName>
                <Note>Убрать возможность привязки к узлу+строке если курсор находится в пустой строке</Note>
                <Text>if (ide.GetCurrentDocumentFileName() == "")</Text>
                <OCtx>
                  <i Type="Method">public static void AddPoint ( IDEInterop ide , TreeManager treeManager , AspectManager Manager , TreeViewAdapter Adapter , TreeNode NewParent , Action Callback )</i>
                  <i Type="ClassOrNamespace">public class EditPointHelper</i>
                  <i Type="ClassOrNamespace">namespace AspectCore . Helpers</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
            </Items>
          </Node>
          <Node Name="Интерфейсное" NL="0" NG="0">
            <Items>
              <Node Name="Перенос привязки в другой файл" NL="0" NG="0">
                <FileName>\system\core\ui\aspectwindowpane.cs</FileName>
                <Text>private void изменитьФайлToolStripMenuItem_Click(object sender, EventArgs e)</Text>
                <OCtx>
                  <i Type="">private void изменитьФайлToolStripMenuItem_Click ( object sender , EventArgs e )</i>
                  <i Type="">public partial class AspectWindowPane : UserControl , IAspectWindow</i>
                  <i Type="">namespace AspectCore</i>
                  <i Type="">
                  </i>
                </OCtx>
                <Items>
                  <Node Name="Шаблон маски диалога" NL="0" NG="0">
                    <FileName>\system\core\strings.cs</FileName>
                    <Text>public static string OFDChangeFileMask = "{0}-файл|*.{0}|Все файлы|*.*";</Text>
                    <OCtx>
                      <i Type="">public class Strings</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                </Items>
              </Node>
              <Node Name="Добавление узла в правильное место" NL="0" NG="0">
                <FileName>\system\core\ui\aspectwindowpane.cs</FileName>
                <Text>if (tvAspects.SelectedNode != null &amp;&amp; Adapter.GetPointByNode(tvAspects.SelectedNode).Context)</Text>
                <OCtx>
                  <i Type="">private void tsbAddPoint_Click ( object sender , EventArgs e )</i>
                  <i Type="">public partial class AspectWindowPane : UserControl , IAspectWindow</i>
                  <i Type="">namespace AspectCore</i>
                  <i Type="">
                  </i>
                </OCtx>
                <Items>
                  <Node Name="И папок" NL="0" NG="0">
                    <FileName>\System\Core\UI\AspectWindowPane.cs</FileName>
                    <Text>private void tsbAddFolder_Click(object sender, EventArgs e)</Text>
                    <OCtx>
                      <i Type="">private void tsbAddFolder_Click ( object sender , EventArgs e )</i>
                      <i Type="">public partial class AspectWindowPane : UserControl , IAspectWindow</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                </Items>
              </Node>
              <Node Name="Импорт/Экспорт" NL="0" NG="0">
                <Items>
                  <Node Name="Экспорт (сериализация)" NL="0" NG="0">
                    <FileName>\system\core\aspectmanager.cs</FileName>
                    <Text>public void SerializeAspect(PointOfInterest subAspect, string FileName, bool Force = false)</Text>
                    <OCtx>
                      <i Type="">public void SerializeAspect ( PointOfInterest subAspect , string FileName , bool Force = false )</i>
                      <i Type="">public class AspectManager</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Десериализация (Импорт)" NL="0" NG="0">
                    <FileName>\system\core\aspectmanager.cs</FileName>
                    <Text>public PointOfInterest DeserializeAspect(string FileName)</Text>
                    <OCtx>
                      <i Type="">public PointOfInterest DeserializeAspect ( string FileName )</i>
                      <i Type="">public class AspectManager</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Вызов экспорта" NL="0" NG="0">
                    <FileName>\system\core\ui\aspectwindowpane.cs</FileName>
                    <Text>private void ExportToolStripMenuItem_Click(object sender, EventArgs e)</Text>
                    <OCtx>
                      <i Type="">private void ExportToolStripMenuItem_Click ( object sender , EventArgs e )</i>
                      <i Type="">public partial class AspectWindowPane : UserControl , IAspectWindow</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Вызов импорта" NL="0" NG="0">
                    <FileName>\system\core\ui\aspectwindowpane.cs</FileName>
                    <Text>private void ImportToolStripMenuItem_Click(object sender, EventArgs e)</Text>
                    <OCtx>
                      <i Type="">private void ImportToolStripMenuItem_Click ( object sender , EventArgs e )</i>
                      <i Type="">public partial class AspectWindowPane : UserControl , IAspectWindow</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Разрешаем перетаскивать файлы" NL="0" NG="0">
                    <FileName>\system\core\ui\aspectwindowpane.cs</FileName>
                    <Text>private void tvAspects_DragEnter(object sender, DragEventArgs e)</Text>
                    <OCtx>
                      <i Type="">private void tvAspects_DragEnter ( object sender , DragEventArgs e )</i>
                      <i Type="">public partial class AspectWindowPane : UserControl , IAspectWindow</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Обработка перетаскивания" NL="0" NG="0">
                    <FileName>\system\core\ui\aspectwindowpane.cs</FileName>
                    <Text>else if (e.Data.GetDataPresent(DataFormats.FileDrop))</Text>
                    <OCtx>
                      <i Type="">private void tvAspects_DragDrop ( object sender , DragEventArgs e )</i>
                      <i Type="">public partial class AspectWindowPane : UserControl , IAspectWindow</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                </Items>
              </Node>
              <Node Name="Отображение процента сходства" NL="0" NG="0">
                <FileName>\system\core\ui\fmselectpoint.cs</FileName>
                <Text>lbCandidates.Items.Add(string.Format(Pattern, ((float)node.TotalMatch/TreeSearchOptions.Equility).ToString("F2"), node.TreeNode.Context[0].Type, string.Join(" ",node.TreeNode.Context[0].Name)));</Text>
                <OCtx>
                  <i Type="Method">private void BuildList ( )</i>
                  <i Type="ClassOrNamespace">public partial class FmSelectPoint : Form</i>
                  <i Type="ClassOrNamespace">namespace AspectCore . UI</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
              <Node Name="Отмена действий" NL="0" NG="0">
                <Items>
                  <Node Name="Главный класс UndoEngine" NL="0" NG="0">
                    <FileName>\System\Core\UndoEngine.cs</FileName>
                    <Text>public class UndoEngine</Text>
                    <OCtx>
                      <i Type="ClassOrNamespace">public class UndoEngine</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                    <ICtx>
                      <i Type="Field">private Stack &lt; UndoUnit &gt; UndoStack = new Stack &lt; UndoUnit &gt; ( )</i>
                      <i Type="Field">private Stack &lt; UndoUnit &gt; RedoStack = new Stack &lt; UndoUnit &gt; ( )</i>
                      <i Type="Method">private UndoUnit CreateUndoUnit ( PointOfInterest point , PointOfInterest parent , ActionKind kind , PointOfInterest newParent = null )</i>
                      <i Type="Method">public void SavePointState ( PointOfInterest point , PointOfInterest parent , ActionKind kind , PointOfInterest newParent = null )</i>
                      <i Type="Method">private UndoUnit CreateReverseUndoAction ( UndoUnit unit )</i>
                      <i Type="Method">public UndoUnit Undo ( )</i>
                      <i Type="Method">public UndoUnit Redo ( )</i>
                      <i Type="Method">public void Clear ( )</i>
                      <i Type="Method">public bool HasUndoActions ( )</i>
                      <i Type="Method">public bool HasRedoActions ( )</i>
                    </ICtx>
                  </Node>
                </Items>
              </Node>
              <Node Name="Добавление/Перепривязка" NL="0" NG="0">
                <Items>
                  <Node Name="Добавление точки" NL="0" NG="0">
                    <FileName>\system\core\ui\aspectwindowpane.cs</FileName>
                    <Text>private void tsbAddPoint_Click(object sender, EventArgs e)</Text>
                    <OCtx>
                      <i Type="Method">private void tsbAddPoint_Click ( object sender , EventArgs e )</i>
                      <i Type="ClassOrNamespace">public partial class AspectWindowPane : UserControl , IAspectWindow</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Изменение привязки" NL="0" NG="0">
                    <FileName>\system\core\ui\aspectwindowpane.cs</FileName>
                    <Text>private void изменитьПривязкуToolStripMenuItem_Click(object sender, EventArgs e)</Text>
                    <OCtx>
                      <i Type="Method">private void изменитьПривязкуToolStripMenuItem_Click ( object sender , EventArgs e )</i>
                      <i Type="ClassOrNamespace">public partial class AspectWindowPane : UserControl , IAspectWindow</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Переход к коду" NL="0" NG="0">
                    <FileName>\system\core\ui\aspectwindowpane.cs</FileName>
                    <Text>private void перейтиККодуToolStripMenuItem_Click(object sender, EventArgs e)</Text>
                    <OCtx>
                      <i Type="Method">private void перейтиККодуToolStripMenuItem_Click ( object sender , EventArgs e )</i>
                      <i Type="ClassOrNamespace">public partial class AspectWindowPane : UserControl , IAspectWindow</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Место фактического добавления/изменения" NL="0" NG="0">
                    <FileName>\System\Core\UI\FmAddPoint.cs</FileName>
                    <Text>private void bOk_Click(object sender, EventArgs e)</Text>
                    <OCtx>
                      <i Type="Method">private void bOk_Click ( object sender , EventArgs e )</i>
                      <i Type="ClassOrNamespace">public partial class fmAddPoint : Form</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                  </Node>
                </Items>
              </Node>
            </Items>
          </Node>
          <Node Name="Внутренний контекст и привязка к промежуточным узлам" NL="0" NG="0">
            <Items>
              <Node Name="Поле в PointOfInterest" NL="0" NG="0">
                <FileName>\system\core\classes.cs</FileName>
                <Note>Убедиться, что сохраняется и читается</Note>
                <Text>public List&lt;InnerContextNode&gt; InnerContext;</Text>
                <OCtx>
                  <i Type="">public List &lt; InnerContextNode &gt; InnerContext</i>
                  <i Type="">[ Serializable ] public class PointOfInterest</i>
                  <i Type="">namespace AspectCore</i>
                  <i Type="">
                  </i>
                </OCtx>
                <Items>
                  <Node Name="Тип поля - InnerContextNode" NL="0" NG="0">
                    <FileName>\system\core\classes.cs</FileName>
                    <Text>public class InnerContextNode</Text>
                    <OCtx>
                      <i Type="">[ Serializable ] public class InnerContextNode</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                    <ICtx>
                      <i Type="">public List &lt; string &gt; Name</i>
                      <i Type="">public List &lt; InnerContextNode &gt; SubNodes</i>
                      <i Type="">[ XmlIgnore ] public bool SubNodesSpecified</i>
                    </ICtx>
                  </Node>
                  <Node Name="Заполнение поля" NL="0" NG="0">
                    <FileName>\system\core\classes.cs</FileName>
                    <Text>public void ApplyInnerContext()</Text>
                    <OCtx>
                      <i Type="">public void ApplyInnerContext ( )</i>
                      <i Type="">[ Serializable ] public class PointOfInterest</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="Выбор структуры поля" NL="0" NG="0">
                    <FileName>\system\core\classes.cs</FileName>
                    <Text>//Вариант</Text>
                    <OCtx>
                      <i Type="">private List &lt; InnerContextNode &gt; GetInnerContext ( List &lt; PointOfInterest &gt; Points )</i>
                      <i Type="">[ Serializable ] public class PointOfInterest</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                </Items>
              </Node>
              <Node Name="Учет контекста при поиске" NL="0" NG="0">
                <FileName>\system\core\treesearchengine.cs</FileName>
                <OCtx>
                  <i Type="">private static void ProcessInnerContext ( TreeSearchResult Result , PointOfInterest Point )</i>
                  <i Type="">public class TreeSearchEngine</i>
                  <i Type="">namespace AspectCore</i>
                  <i Type="">
                  </i>
                </OCtx>
              </Node>
              <Node Name="Включение привязки в интерфейсе" NL="-1" NG="0,1044922">
                <FileName>\System\Core\UI\FmAddPoint.cs</FileName>
                <Note>Проверка уникальности узла. Если узел не уникален - внутренний контекст запоминается</Note>
                <Text>public partial class fmAddPoint : Form</Text>
                <OCtx>
                  <i Type="ClassOrNamespace">public partial class fmAddPoint : Form</i>
                  <i Type="ClassOrNamespace">namespace AspectCore</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
                <ICtx>
                  <i Type="Field">public List &lt; PointOfInterest &gt; AnchorPoints</i>
                  <i Type="Field">public TreeViewAdapter Adapter</i>
                  <i Type="Field">public TreeNode Node</i>
                  <i Type="Field">public bool IsAddNewNode</i>
                  <i Type="Field">Action Callback</i>
                  <i Type="Method">public fmAddPoint ( TreeViewAdapter Adapter )</i>
                  <i Type="Method">public void SyncronizeControlsWithPoint ( List &lt; PointOfInterest &gt; points , TreeNode Node , bool IsAdd , Action CallBack )</i>
                  <i Type="Method">public void SyncronizePointWithControls ( )</i>
                  <i Type="Method">private void cbAddAnchorPoint_CheckedChanged ( object sender , EventArgs e )</i>
                  <i Type="Method">private void bCancel_Click ( object sender , EventArgs e )</i>
                </ICtx>
              </Node>
              <Node Name="Структура дерева в парсере Паскаля" NL="0" NG="0">
                <FileName>\Parsers\LWParserPascal\ParserDescriptor.lp</FileName>
                <Note>Готово</Note>
                <Text>Rule Defs :				[@tkDefs|@"type"] List1(FieldOrClass)</Text>
                <OCtx>
                  <i Type="">Defs</i>
                  <i Type="">
                  </i>
                </OCtx>
              </Node>
              <Node Name="Доделать: поиск с учетом промежуточных узлов" NL="0" NG="0">
                <FileName>\system\core\ui\aspectwindowpane.cs</FileName>
                <Note>Поиск узла в дереве аспектов должен учитывать привязку не только к листу дерева разбора, но и к промежуточным узлам.</Note>
                <Text>PointOfInterest pt = EditPointHelper.FindPointUnderCursor(ide, treeManager);</Text>
                <OCtx>
                  <i Type="">private void tsbFindNode_Click ( object sender , EventArgs e )</i>
                  <i Type="">public partial class AspectWindowPane : UserControl , IAspectWindow</i>
                  <i Type="">namespace AspectCore</i>
                  <i Type="">
                  </i>
                </OCtx>
              </Node>
              <Node Name="Ограничение на внутренний контекст" NL="0" NG="0">
                <FileName>\system\core\classes.cs</FileName>
                <Note>Пока - линейный список из не более чем 10 элементов.</Note>
                <Text>public void ApplyInnerContext()</Text>
                <OCtx>
                  <i Type="">public void ApplyInnerContext ( )</i>
                  <i Type="">public class PointOfInterest : ISerializable</i>
                  <i Type="">namespace AspectCore</i>
                  <i Type="">
                  </i>
                </OCtx>
                <Items>
                  <Node Name="Константа MaxInnerContectCount" NL="0" NG="0">
                    <FileName>\System\Core\TreeSearchEngine.cs</FileName>
                    <Text>public const int MaxInnerContectCount = 10;</Text>
                    <OCtx>
                      <i Type="">public const int MaxInnerContectCount = 10</i>
                      <i Type="">internal static class TreeSearchOptions</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                  </Node>
                </Items>
              </Node>
            </Items>
          </Node>
          <Node Name="Поиск" NL="0" NG="0">
            <Items>
              <Node Name="Движок поиска" NL="0" NG="0">
                <Items>
                  <Node Name="Главный класс TreeSearchEngine" NL="0,875" NG="0,4208984">
                    <FileName>\system\core\treesearchengine.cs</FileName>
                    <Text>public class TreeSearchEngine</Text>
                    <OCtx>
                      <i Type="ClassOrNamespace">public class TreeSearchEngine</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                    <ICtx>
                      <i Type="Method">public static TreeSearchResult FindPointInTree ( PointOfInterest TreeRoot , PointOfInterest Point , string SourceText )</i>
                      <i Type="Method">public static TreeSearchResult FindPointInTree2 ( PointOfInterest TreeRoot , PointOfInterest Point , string SourceText )</i>
                      <i Type="Method">public static PointOfInterest FindPointInAspectTree ( PointOfInterest WorkingAspect , PointOfInterest Point )</i>
                      <i Type="Method">public static List &lt; PointOfInterest &gt; FindPointByLocation ( PointOfInterest p , int line , int col )</i>
                      <i Type="Method">public static void SetNearLG ( PointOfInterest TreeRoot , PointOfInterest point , string Text , out float NearL , out float NearG )</i>
                      <i Type="Method">private static TreeSearchResult InitializeResultFromTree ( PointOfInterest TreeRoot , string Type )</i>
                      <i Type="Method">private static HashSet &lt; PointOfInterest &gt; GetNeighbours ( PointOfInterest TreeRoot , PointOfInterest point )</i>
                      <i Type="Method">private static float GetMaxSimilarityByName ( TreeSearchResult Nodes , PointOfInterest point , string Text )</i>
                      <i Type="Method">private static void ProcessIDs ( TreeSearchResult Result , PointOfInterest Point , bool Full = false )</i>
                      <i Type="Method">private static void ProcessHeaders ( TreeSearchResult Result , PointOfInterest Point , bool Full = false )</i>
                    </ICtx>
                    <Items>
                      <Node Name="Главный метод поиска FindPointInTree" NL="0,71875" NG="0,5791016">
                        <FileName>\System\Core\TreeSearchEngine.cs</FileName>
                        <Text>public static TreeSearchResult FindPointInTree(PointOfInterest TreeRoot, PointOfInterest Point, string SourceText)</Text>
                        <OCtx>
                          <i Type="Method">public static TreeSearchResult FindPointInTree ( PointOfInterest TreeRoot , PointOfInterest Point , string SourceText )</i>
                          <i Type="ClassOrNamespace">public class TreeSearchEngine</i>
                          <i Type="ClassOrNamespace">namespace AspectCore</i>
                          <i Type="CS_TreeNode">
                          </i>
                        </OCtx>
                      </Node>
                    </Items>
                  </Node>
                  <Node Name="Сравнение объектов, класс TreeSearchComparer" NL="0" NG="0">
                    <FileName>\system\core\treesearchengine.cs</FileName>
                    <Note>Класс TreeSearchComparer реализует набор методов для четкого и нечеткого сравнения строк, списков строк.</Note>
                    <Text>private static class TreeSearchComparer</Text>
                    <OCtx>
                      <i Type="">internal static class TreeSearchComparer</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                    <ICtx>
                      <i Type="">public bool ListsEqual ( List &lt; string &gt; L1 , List &lt; string &gt; L2 )</i>
                      <i Type="">public bool ListsEqual ( List &lt; List &lt; string &gt; &gt; L1 , List &lt; List &lt; string &gt; &gt; L2 )</i>
                    </ICtx>
                    <Items>
                      <Node Name="Класс LevenshteinSimilarity" NL="0,8681641" NG="0,546875">
                        <FileName>\system\core\treesearchengine.cs</FileName>
                        <Note>Реализуем методы, возвращающие степень похожести для строк, имен (списков строк), контекстов (списков списков строк)</Note>
                        <Text>private static class LevenshteinSimilarity</Text>
                        <OCtx>
                          <i Type="ClassOrNamespace">private static class LevenshteinSimilarity</i>
                          <i Type="ClassOrNamespace">internal static class TreeSearchComparer</i>
                          <i Type="ClassOrNamespace">namespace AspectCore</i>
                          <i Type="CS_TreeNode">
                          </i>
                        </OCtx>
                        <ICtx>
                          <i Type="Field">static System . Collections . Concurrent . ConcurrentDictionary &lt; StringPairKey , int &gt; _Similarity = new System . Collections . Concurrent . ConcurrentDictionary &lt; StringPairKey , int &gt; ( )</i>
                          <i Type="Method">public static int Similarity ( string S1 , string S2 )</i>
                          <i Type="Method">public static int Similarity ( dynamic L1 , dynamic L2 )</i>
                          <i Type="Method">public static void ClearDictionary ( )</i>
                        </ICtx>
                      </Node>
                      <Node Name="Класс JaroWinklerSimilarity" NL="0" NG="0">
                        <FileName>\system\core\treesearchengine.cs</FileName>
                        <Note>Содержит метод, вычисляющий степень похожести двух строк.</Note>
                        <Text>private static class JaroWinklerSimilarity</Text>
                        <OCtx>
                          <i Type="">private static class JaroWinklerSimilarity</i>
                          <i Type="">internal static class TreeSearchComparer</i>
                          <i Type="">namespace AspectCore</i>
                          <i Type="">
                          </i>
                        </OCtx>
                        <ICtx>
                          <i Type="">static Dictionary &lt; StringPairKey , int &gt; _Similarity = new Dictionary &lt; StringPairKey , int &gt; ( )</i>
                          <i Type="">private static readonly double mWeightThreshold = 0 . 7</i>
                          <i Type="">private static readonly int mNumChars = 4</i>
                          <i Type="">public static int Similarity ( string S1 , string S2 )</i>
                        </ICtx>
                      </Node>
                      <Node Name="Ключ для словаря" NL="0" NG="0">
                        <FileName>\system\core\treesearchengine.cs</FileName>
                        <Note>Так как степень похожести строк вычисляется часто, имеет смысл запоминать результаты вычисления в словаре.
Данный класс хранит пару строк и используется в качестве ключа для методов вычисления степени похожести пары строк.
Строки хранятся в упорядоченном виде, поэтому пары (A, B) и (B, A) равны. Отсюда следует требование к методам вычисления степени похожести: D(A, B) = D(B, A).

</Note>
                        <Text>private struct StringPairKey</Text>
                        <OCtx>
                          <i Type="">private struct StringPairKey</i>
                          <i Type="">namespace AspectCore</i>
                          <i Type="">
                          </i>
                        </OCtx>
                      </Node>
                    </Items>
                  </Node>
                  <Node Name="Поиск текстовой строки TextSearch" NL="0" NG="0">
                    <FileName>\System\Core\TreeSearchEngine.cs</FileName>
                    <Note>Класс инициализируется текстом текущего файла и содержит метод для нечеткого поиска строки-образца в заданном диапазоне. Возвращает номер наиболее похожей строки и степень ее похожести.</Note>
                    <Text>internal class TextSearch</Text>
                    <OCtx>
                      <i Type="">internal class TextSearch</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                    <ICtx>
                      <i Type="">string [ ] _lines</i>
                      <i Type="">public TextSearch ( string Text )</i>
                      <i Type="">public Pair &lt; int , int &gt; Similarity ( QUT . Gppg . LexLocation Loc , string pattern )</i>
                      <i Type="">private List &lt; string &gt; TokenizeString ( string str )</i>
                      <i Type="">private List &lt; List &lt; string &gt; &gt; TokenizeStrings ( string [ ] Array , int start , int end )</i>
                    </ICtx>
                  </Node>
                  <Node Name="Опции поиска TreeSearchOptions" NL="0" NG="0">
                    <FileName>\System\Core\TreeSearchEngine.cs</FileName>
                    <Text>internal static class TreeSearchOptions</Text>
                    <OCtx>
                      <i Type="">internal static class TreeSearchOptions</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                    <ICtx>
                      <i Type="">public const int CostInsertChar = 1</i>
                      <i Type="">public const int CostRemoveChar = 1</i>
                      <i Type="">public const int CostReplaceChar = 1</i>
                      <i Type="">public const int MaxDistanceToReturn = 10</i>
                      <i Type="">public const int MaxDistanceDifference = 5</i>
                    </ICtx>
                  </Node>
                  <Node Name="Класс результата TreeSearchResult" NL="0" NG="0">
                    <FileName>\System\Core\TreeSearchEngine.cs</FileName>
                    <Note>Хранит массив элементов результата.
Умеет сортировать массив в соответствии с заданными весами компонентовм.
Можно получить узел дерева а также его степень похожести при заданных весах компонентов, Double, от 0 (не соответствует) до 1 (совпадает)

TODO: отсечение слишком непохожих результатов по заданному порогу</Note>
                    <Text>public class TreeSearchResult</Text>
                    <OCtx>
                      <i Type="">public class TreeSearchResult</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                    <ICtx>
                      <i Type="">public readonly bool Singular</i>
                      <i Type="">internal List &lt; TreeSearchResultNode &gt; _result = new List &lt; TreeSearchResultNode &gt; ( )</i>
                      <i Type="">public PointOfInterest this [ int Index ]</i>
                      <i Type="">public double Similarity ( int Index )</i>
                      <i Type="">public int Count</i>
                      <i Type="">private int _wName = 1</i>
                      <i Type="">private int _wOuterCTX = 1</i>
                      <i Type="">private int _wInnerCTX = 1</i>
                      <i Type="">private int _wText = 1</i>
                      <i Type="">public void Sort ( )</i>
                      <i Type="">public void Sort ( int NameWeight , int OuterCtxWeight , int InnerCtxWeight , int TextWeight )</i>
                    </ICtx>
                  </Node>
                  <Node Name="Элемент результата TreeSearchResultNode" NL="0" NG="0">
                    <FileName>\System\Core\TreeSearchEngine.cs</FileName>
                    <Note>Хранит узел дерева и степень похожести его компонентов на искомый узел</Note>
                    <Text>internal class TreeSearchResultNode</Text>
                    <OCtx>
                      <i Type="">internal class TreeSearchResultNode</i>
                      <i Type="">namespace AspectCore</i>
                      <i Type="">
                      </i>
                    </OCtx>
                    <ICtx>
                      <i Type="">public PointOfInterest TreeNode</i>
                      <i Type="">public int NameMatch</i>
                      <i Type="">public int OuterContextMatch</i>
                      <i Type="">public int InnercontextMatch</i>
                      <i Type="">public int TextStringMatch</i>
                    </ICtx>
                  </Node>
                </Items>
              </Node>
              <Node Name="Доделать" NL="0" NG="0">
                <Items>
                  <Node Name="Чувствительность к регистру" NL="0" NG="0">
                    <FileName>\System\Core\TreeSearchEngine.cs</FileName>
                    <Note>Если исходный язык нечувствительный к регистру - учесть это при сравнении</Note>
                    <Text>public static int Similarity(string S1, string S2)</Text>
                    <OCtx>
                      <i Type="Method">public static int Similarity ( string S1 , string S2 )</i>
                      <i Type="ClassOrNamespace">private static class LevenshteinSimilarity</i>
                      <i Type="ClassOrNamespace">internal static class TreeSearchComparer</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                    <Items>
                      <Node Name="Добавить в интерфейс парсера информацию о регистре" NL="0" NG="0">
                        <FileName>\System\Core\Classes.cs</FileName>
                        <Text>public abstract class LightweightParserBase</Text>
                        <OCtx>
                          <i Type="ClassOrNamespace">public abstract class LightweightParserBase</i>
                          <i Type="ClassOrNamespace">namespace AspectCore</i>
                          <i Type="CS_TreeNode">
                          </i>
                        </OCtx>
                        <ICtx>
                          <i Type="Method">public abstract SourceEntity Root</i>
                          <i Type="Method">public abstract List &lt; SourceEntity &gt; Errors</i>
                          <i Type="Field">public abstract bool Parse ( )</i>
                          <i Type="Method">public abstract string [ ] LanguageID</i>
                          <i Type="Method">public virtual void ProcessTree ( )</i>
                        </ICtx>
                      </Node>
                    </Items>
                  </Node>
                </Items>
              </Node>
              <Node Name="Сохранение метрики похожести" NL="0" NG="0">
                <Items>
                  <Node Name="Вычисление констант NearL/G" NL="0" NG="0">
                    <FileName>\system\core\treesearchengine.cs</FileName>
                    <Note>Множества TreeL/G получены, осталось вычислить степени похожести имен и найти наиболее похожее</Note>
                    <Text>public static void GetNearLG(PointOfInterest TreeRoot, PointOfInterest point, out float NearL, out float NearG)</Text>
                    <OCtx>
                      <i Type="Method">public static void GetNearLG ( PointOfInterest TreeRoot , PointOfInterest point , out float NearL , out float NearG )</i>
                      <i Type="ClassOrNamespace">public class TreeSearchEngine</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="GetNeighbours" NL="0" NG="0">
                    <FileName>\system\core\treesearchengine.cs</FileName>
                    <Note>Получение множества соседей.
Используется для разделения множества всех узлов на два множества - локальные и глобальные узлы по отношению к искомому</Note>
                    <Text>private static HashSet&lt;PointOfInterest&gt; GetNeighbours(PointOfInterest TreeRoot, PointOfInterest point)</Text>
                    <OCtx>
                      <i Type="Method">private static HashSet &lt; PointOfInterest &gt; GetNeighbours ( PointOfInterest TreeRoot , PointOfInterest point )</i>
                      <i Type="ClassOrNamespace">public class TreeSearchEngine</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="GetMaxSimilarityByName" NL="0" NG="0">
                    <FileName>\system\core\treesearchengine.cs</FileName>
                    <Note>Вычисляет метрику имени для наиболее похожего узла в заданном множестве</Note>
                    <Text>private static float GetMaxSimilarityByName(TreeSearchResult Nodes, PointOfInterest point)</Text>
                    <OCtx>
                      <i Type="Method">private static float GetMaxSimilarityByName ( TreeSearchResult Nodes , PointOfInterest point )</i>
                      <i Type="ClassOrNamespace">public class TreeSearchEngine</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="NearL" NL="0" NG="0">
                    <FileName>\system\core\classes.cs</FileName>
                    <Text>public float NearL = 0;</Text>
                    <OCtx>
                      <i Type="Field">public float NearL = 0</i>
                      <i Type="ClassOrNamespace">public class PointOfInterest : ISerializable</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                  </Node>
                  <Node Name="NearG" NL="0" NG="0">
                    <FileName>\system\core\classes.cs</FileName>
                    <Text>public float NearG = 0;</Text>
                    <OCtx>
                      <i Type="Field">public float NearG = 0</i>
                      <i Type="ClassOrNamespace">public class PointOfInterest : ISerializable</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                  </Node>
                </Items>
              </Node>
            </Items>
          </Node>
          <Node Name="Парсеры" NL="0" NG="0">
            <Items>
              <Node Name="Главный классParserWrapper" NL="0" NG="0">
                <FileName>\System\Core\ParserWrapper.cs</FileName>
                <Text>public class ParserWrapper</Text>
                <OCtx>
                  <i Type="ClassOrNamespace">public class ParserWrapper</i>
                  <i Type="ClassOrNamespace">namespace AspectCore</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
                <ICtx>
                  <i Type="Field">private static string ScannerClassName =</i>
                  <i Type="Field">private static string ParserClassName =</i>
                  <i Type="Field">private Dictionary &lt; string , LightweightParserBase &gt; parsers = new Dictionary &lt; string , LightweightParserBase &gt; ( )</i>
                  <i Type="Field">private Dictionary &lt; string , ILightWeightScanner &gt; scanners = new Dictionary &lt; string , ILightWeightScanner &gt; ( )</i>
                  <i Type="Field">private LightweightParserBase DefaultParser</i>
                  <i Type="Field">private ILightWeightScanner DefaultScanner</i>
                  <i Type="Field">private List &lt; PointOfInterest &gt; _LastTimeErrors = new List &lt; PointOfInterest &gt; ( )</i>
                  <i Type="Method">public ParserWrapper ( )</i>
                  <i Type="Method">public ParserWrapper ( string Path )</i>
                  <i Type="Method">public void ReloadParsers ( )</i>
                </ICtx>
              </Node>
            </Items>
          </Node>
          <Node Name="Хранение синтаксических деревьев" NL="0" NG="0">
            <Items>
              <Node Name="Главный класс TreeManager" NL="0" NG="0">
                <FileName>\System\Core\TreeManager.cs</FileName>
                <Text>public class TreeManager</Text>
                <OCtx>
                  <i Type="ClassOrNamespace">public class TreeManager</i>
                  <i Type="ClassOrNamespace">namespace AspectCore</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
                <ICtx>
                  <i Type="Field">ParserWrapper parserWrapper</i>
                  <i Type="Field">Dictionary &lt; string , PointOfInterest &gt; FilenameToTree = new Dictionary &lt; string , PointOfInterest &gt; ( )</i>
                  <i Type="Field">Dictionary &lt; string , string &gt; FilenameToText = new Dictionary &lt; string , string &gt; ( )</i>
                  <i Type="Field">Dictionary &lt; string , DateTime &gt; FilenameToDateTime = new Dictionary &lt; string , DateTime &gt; ( )</i>
                  <i Type="Field">List &lt; PointOfInterest &gt; _LastTimeErrors</i>
                  <i Type="Method">public TreeManager ( string ParsersPath = )</i>
                  <i Type="Method">public ParserWrapper Parsers</i>
                  <i Type="Method">public List &lt; string &gt; GetParserIDs ( )</i>
                  <i Type="Method">public int GetParsersCount ( )</i>
                  <i Type="Method">public List &lt; PointOfInterest &gt; GetLastParseErrors ( )</i>
                </ICtx>
              </Node>
            </Items>
          </Node>
          <Node Name="Интеграция в IDE" NL="0" NG="0">
            <Items>
              <Node Name="Интерфейс IDEInterop" NL="0" NG="0">
                <FileName>\System\Core\IDEInterop.cs</FileName>
                <Text>public class IDEInterop</Text>
                <OCtx>
                  <i Type="ClassOrNamespace">public class IDEInterop</i>
                  <i Type="ClassOrNamespace">namespace AspectCore</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
                <ICtx>
                  <i Type="Method">public virtual bool IsDocumentOpen ( )</i>
                  <i Type="Method">public virtual bool IsDocumentOpen ( string FileName )</i>
                  <i Type="Method">public virtual string GetCurrentTextDocument ( )</i>
                  <i Type="Method">public virtual string GetCurrentDocumentFileName ( )</i>
                  <i Type="Method">public virtual string GetDocument ( string FileName )</i>
                  <i Type="Method">public virtual string GetCurrentLine ( )</i>
                  <i Type="Method">public virtual string GetLine ( int lineIndex )</i>
                  <i Type="Method">public virtual LexLocation GetCursorPosition ( )</i>
                  <i Type="Method">public virtual void NavigateToFileAndPosition ( string file , int line , int col , int lineEnd = 0 , int columnEnd = 0 )</i>
                  <i Type="Method">public virtual void UpdateSubAspectProperties ( PointOfInterest point , System . Windows . Forms . TreeNode node )</i>
                </ICtx>
              </Node>
            </Items>
          </Node>
          <Node Name="Хранение дерева аспектов AXML" NL="0" NG="0">
            <Items>
              <Node Name="Реализация чтения: по версиям" NL="0" NG="0">
                <Items>
                  <Node Name="AspectFileReader" NL="0" NG="0">
                    <FileName>\system\core\aspectmanager.cs</FileName>
                    <Note>Базовый класс</Note>
                    <Text>internal class AspectFileReader</Text>
                    <OCtx>
                      <i Type="ClassOrNamespace">internal class AspectFileReader</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                    <ICtx>
                      <i Type="Method">protected static XmlNode TryFindNode ( XmlNode Node , string Name )</i>
                      <i Type="Method">protected static string TryFindValue ( XmlNode node , string Name )</i>
                      <i Type="Method">protected static List &lt; string &gt; TryReadListOfStrings ( XmlNode Node )</i>
                    </ICtx>
                  </Node>
                  <Node Name="AspectFileV1Reader" NL="0" NG="0">
                    <FileName>\system\core\aspectmanager.cs</FileName>
                    <Note>Чтение первой версии XML</Note>
                    <Text>internal class AspectFileV1Reader : AspectFileReader</Text>
                    <OCtx>
                      <i Type="ClassOrNamespace">internal class AspectFileV1Reader : AspectFileReader</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                    <ICtx>
                      <i Type="Method">public static PointOfInterest BuildTreeFromXML ( XmlElement Element )</i>
                      <i Type="Method">private static PointOfInterest ConvertXMLNodeToPointOfInterest ( XmlNode Node )</i>
                      <i Type="Method">private static List &lt; OuterContextNode &gt; TryReadOuterContext ( XmlNode Node )</i>
                      <i Type="Method">private static List &lt; InnerContextNode &gt; TryReadInnerContext ( XmlNode Node )</i>
                    </ICtx>
                  </Node>
                  <Node Name="AspectFileV2Reader" NL="0" NG="0">
                    <FileName>\system\core\aspectmanager.cs</FileName>
                    <Note>Чтение второй версии XML</Note>
                    <Text>internal class AspectFileV2Reader : AspectFileReader</Text>
                    <OCtx>
                      <i Type="ClassOrNamespace">internal class AspectFileV2Reader : AspectFileReader</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                    <ICtx>
                      <i Type="Method">public static PointOfInterest BuildTreeFromXML ( XmlNode Node )</i>
                      <i Type="Method">private static List &lt; OuterContextNode &gt; TryReadOuterContext ( XmlNode Node )</i>
                      <i Type="Method">private static OuterContextNode TryReadOuterContextNode ( XmlNode Node )</i>
                      <i Type="Method">private static List &lt; InnerContextNode &gt; TryReadInnerContext ( XmlNode Node )</i>
                      <i Type="Method">private static InnerContextNode TryReadInnerContextNode ( XmlNode Node )</i>
                    </ICtx>
                  </Node>
                  <Node Name="AspectFileV3Reader" NL="0" NG="0">
                    <FileName>\system\core\aspectmanager.cs</FileName>
                    <Note>Чтение третьей версии XML</Note>
                    <Text>internal class AspectFileV3Reader : AspectFileReader</Text>
                    <OCtx>
                      <i Type="ClassOrNamespace">internal class AspectFileV3Reader : AspectFileReader</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                    <ICtx>
                      <i Type="Method">public static PointOfInterest BuildTreeFromXML ( XmlNode Node )</i>
                      <i Type="Method">private static List &lt; OuterContextNode &gt; TryReadOuterContext ( XmlNode Node )</i>
                      <i Type="Method">private static OuterContextNode TryReadOuterContextNode ( XmlNode Node )</i>
                      <i Type="Method">private static List &lt; InnerContextNode &gt; TryReadInnerContext ( XmlNode Node )</i>
                      <i Type="Method">private static InnerContextNode TryReadInnerContextNode ( XmlNode Node )</i>
                    </ICtx>
                  </Node>
                </Items>
              </Node>
              <Node Name="Реализация записи: AspectFileBuilder" NL="0" NG="0">
                <FileName>\system\core\aspectmanager.cs</FileName>
                <Note>Класс, сохраняющий дерево аспектов в XML текущей версии</Note>
                <Text>internal class AspectFileBuilder</Text>
                <OCtx>
                  <i Type="ClassOrNamespace">internal class AspectFileBuilder</i>
                  <i Type="ClassOrNamespace">namespace AspectCore</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
                <ICtx>
                  <i Type="Method">public static XmlElement BuildXMLTree ( PointOfInterest AspectTree , XmlDocument Doc )</i>
                  <i Type="Method">private static XmlNode BuildInnerContext ( List &lt; InnerContextNode &gt; IC , XmlDocument Doc )</i>
                  <i Type="Method">private static XmlNode BuildInnerContextNode ( InnerContextNode IN , XmlDocument Doc )</i>
                  <i Type="Method">private static XmlNode BuildOuterContext ( List &lt; OuterContextNode &gt; OC , XmlDocument Doc )</i>
                  <i Type="Method">private static XmlNode BuildPoint ( PointOfInterest Point , XmlDocument Doc )</i>
                </ICtx>
              </Node>
              <Node Name="Чтение / Выбор версии" NL="0" NG="0">
                <FileName>\system\core\aspectmanager.cs</FileName>
                <Text>if (attr.Name == "Version")</Text>
                <OCtx>
                  <i Type="Method">public PointOfInterest DeserializeAspect ( string FileName , ParserWrapper _parserWrapper )</i>
                  <i Type="ClassOrNamespace">public class AspectManager</i>
                  <i Type="ClassOrNamespace">namespace AspectCore</i>
                  <i Type="CS_TreeNode">
                  </i>
                </OCtx>
              </Node>
              <Node Name="Опасные места" NL="0" NG="0">
                <Items>
                  <Node Name="Жестко зашитые константы EOF" NL="0" NG="0">
                    <FileName>\System\Core\AspectManager.cs</FileName>
                    <Note>Для Standalone лексера (CommonLexer) EOF == 0.
Если для лексера есть парсер, то лексемы определены в парсере и там EOF == 3.
По-умалчанию это так. </Note>
                    <Text>//Warning - hardcoded constants. May be wrong.</Text>
                    <OCtx>
                      <i Type="Method">private static List &lt; string &gt; TokenizeString ( string Str , dynamic Lexer )</i>
                      <i Type="ClassOrNamespace">internal class AspectFileV3Reader : AspectFileReader</i>
                      <i Type="ClassOrNamespace">namespace AspectCore</i>
                      <i Type="CS_TreeNode">
                      </i>
                    </OCtx>
                  </Node>
                </Items>
              </Node>
            </Items>
          </Node>
        </Items>
      </Node>
    </Items>
  </Node>
</AspectFile>